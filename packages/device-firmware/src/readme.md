# Source Code Architecture

This directory contains the main firmware modules for the Teensy 4.1 LED controller.

## Overview

The firmware receives UDP packets containing LED frame data, assembles complete frames, and drives WS2815 LED strips in parallel using OctoWS2811. It reports status back to the sender via active heartbeat messages.

## Main Loop

The firmware follows a cooperative loop architecture:

**setup()**: Initializes all subsystems in order
- LED driver (sets strips to black)
- Wakeup effect state machine
- Receiver frame assembly
- Network (Ethernet + UDP sockets)
- Status heartbeat
- Onboard LED indicator

**loop()**: Polls subsystems continuously
- Wakeup effect (blocks until complete)
- Network polling for incoming packets
- Frame display when complete frame ready
- Status heartbeat transmission
- LED status indicator updates

## Module Descriptions

### main.cpp
Entry point containing `setup()` and `loop()` functions. Coordinates initialization sequence and polls all subsystems in the main loop.

### network (network.cpp/h)
Manages Ethernet connection and UDP communication:
- Initializes QNEthernet with static IP configuration
- Binds UDP sockets on `PORT_BASE + run_index` for each run
- Polls for incoming packets and dispatches to receiver
- Sends status heartbeat JSON to sender
- Monitors Ethernet link status

### receiver (receiver.cpp/h)
Handles UDP packet reception and frame assembly:
- Validates packet length against expected LED count
- Tracks session_id for sender restart detection
- Assembles frames by matching frame_id across all runs
- Maintains up to 2 frame slots (current/next)
- Applies frame only when all runs complete
- Tracks statistics: rx_frames, complete_frames, applied_frames, drops
- Reports errors via heartbeat

### led_driver (led_driver.cpp/h)
Drives WS2815 LED strips via OctoWS2811:
- Converts RGB to GRB color format
- Manages DMA-based parallel output to all 8 strips
- Enforces 1-second startup blackout period
- Checks DMA busy state before frame updates
- Provides black-out functionality

### status (status.cpp/h)
Generates and sends active status heartbeats:
- Sends JSON heartbeat every 1 second
- Includes uptime, link status, statistics, and errors
- Unicasts to configured sender IP and port
- Resets statistics after each heartbeat

### led_status (led_status.cpp/h)
Controls onboard LED (pin 13) for visual status indication:
- Slow blink until first frame received
- Quick tick on frame display for first 600 frames
- Provides visual feedback of system operation

### wakeup (wakeup.cpp/h)
Runs a visual startup sequence before accepting network input:
- Lights each run sequentially in warm white at 50% brightness
- Each run lit for 200ms with 50ms gap between runs
- Blocks all network frame processing until complete
- Provides visual confirmation that all LED runs are functional

### hal/ (Hardware Abstraction Layer)
Platform abstraction for portability and testing. See `hal/readme.md` for details.

### config_autogen.h
Build-time generated configuration from JSON layout files:
- SIDE_ID, RUN_COUNT, LED_COUNT[]
- Network configuration (IP addresses, ports)
- Generated by `scripts/gen_config.py`

## Data Flow

1. On startup, wakeup effect lights each run sequentially (200ms each)
2. After wakeup completes, network input is accepted
3. Sender transmits UDP packets to `PORT_BASE + run_index` for each run
4. Network module receives packets and passes to receiver
5. Receiver validates, assembles frames by frame_id
6. When complete frame ready, main loop passes to led_driver
7. LED driver converts RGB to GRB and triggers DMA output
8. Status module sends periodic heartbeats with statistics
9. LED status provides visual feedback on onboard LED

## Dependencies

Modules depend on each other in this order (top depends on bottom):
- main.cpp
- network, receiver, led_driver, status, led_status, wakeup
- hal (hardware abstraction layer)
- config_autogen.h (build-time generated)

## Key Design Principles

- Cooperative single-threaded architecture (no RTOS)
- DMA-based LED output (zero CPU overhead during transmission)
- Active heartbeat for monitoring and debugging
- Build-time configuration from JSON layouts
- Clean module boundaries with minimal coupling
- Hardware abstraction enables native testing
