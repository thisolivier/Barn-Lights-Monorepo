#!/usr/bin/env python3
"""
Generate config_autogen.h from device JSON configuration.

Usage:
    python scripts/gen_config.py config/left.json > src/config_autogen.h
    python scripts/gen_config.py config/right.json > src/config_autogen.h
"""

import json
import sys
from pathlib import Path


def validate_config(config: dict) -> None:
    """Validate configuration values."""
    runs = config.get("runs", [])
    run_count = len(runs)

    if run_count > 8:
        raise ValueError(f"RUN_COUNT ({run_count}) exceeds maximum of 8")

    for run in runs:
        led_count = run.get("led_count", 0)
        if led_count > 800:
            raise ValueError(f"LED_COUNT ({led_count}) for run {run['run_index']} exceeds maximum of 800")

    # Validate IP addresses are lists of 4 integers
    for key in ["static_ip", "static_netmask", "static_gateway"]:
        ip = config.get(key, [])
        if len(ip) != 4 or not all(isinstance(b, int) and 0 <= b <= 255 for b in ip):
            raise ValueError(f"Invalid {key}: {ip}")


def generate_header(config: dict) -> str:
    """Generate C++ header content from config."""
    side = config["side"].upper()
    runs = config.get("runs", [])
    run_count = len(runs)

    # Extract LED counts per run
    led_counts = [run["led_count"] for run in runs]
    max_leds = max(led_counts) if led_counts else 0

    # Calculate expected mask (bitmask of which runs are active)
    expected_mask = (1 << run_count) - 1

    # Network config
    static_ip = config["static_ip"]
    static_netmask = config["static_netmask"]
    static_gateway = config["static_gateway"]
    port_base = config.get("port_base", 49600)
    status_port = config.get("gateway_telemetry_port", 49700)

    # Sender IP is the gateway
    sender_ip = static_gateway

    lines = [
        "// Auto-generated by gen_config.py - DO NOT EDIT",
        "#pragma once",
        "",
        "#include <cstdint>",
        "",
        f'#define SIDE_ID "{side}"',
        f"#define RUN_COUNT {run_count}",
        f"#define MAX_LEDS {max_leds}",
        f"#define EXPECTED_MASK 0x{expected_mask:02X}",
        "",
        "// LED counts per run",
        f"constexpr uint16_t LED_COUNT[RUN_COUNT > 0 ? RUN_COUNT : 1] = {{{', '.join(str(c) for c in led_counts)}}};",
        "",
        "// Network configuration",
        f"#define STATIC_IP_0 {static_ip[0]}",
        f"#define STATIC_IP_1 {static_ip[1]}",
        f"#define STATIC_IP_2 {static_ip[2]}",
        f"#define STATIC_IP_3 {static_ip[3]}",
        "",
        f"#define STATIC_NETMASK_0 {static_netmask[0]}",
        f"#define STATIC_NETMASK_1 {static_netmask[1]}",
        f"#define STATIC_NETMASK_2 {static_netmask[2]}",
        f"#define STATIC_NETMASK_3 {static_netmask[3]}",
        "",
        f"#define STATIC_GATEWAY_0 {static_gateway[0]}",
        f"#define STATIC_GATEWAY_1 {static_gateway[1]}",
        f"#define STATIC_GATEWAY_2 {static_gateway[2]}",
        f"#define STATIC_GATEWAY_3 {static_gateway[3]}",
        "",
        f"#define SENDER_IP_0 {sender_ip[0]}",
        f"#define SENDER_IP_1 {sender_ip[1]}",
        f"#define SENDER_IP_2 {sender_ip[2]}",
        f"#define SENDER_IP_3 {sender_ip[3]}",
        "",
        f"#define PORT_BASE {port_base}",
        f"#define STATUS_PORT {status_port}",
        "",
    ]

    return "\n".join(lines)


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <config.json>", file=sys.stderr)
        sys.exit(1)

    config_path = Path(sys.argv[1])
    if not config_path.exists():
        print(f"Error: Config file not found: {config_path}", file=sys.stderr)
        sys.exit(1)

    with open(config_path) as f:
        config = json.load(f)

    validate_config(config)
    header = generate_header(config)
    print(header)


if __name__ == "__main__":
    main()
